{"version":3,"sources":["components/posts/subway_map.jpeg","components/posts/graph_visual.png","components/posts/inefficiency_fitness_eq.svg","components/posts/equationsP1/eigen1.svg","components/posts/equationsP1/eigen2.svg","components/posts/equationsP1/eigen3.svg","components/posts/equationsP1/Robustness.svg","components/posts/equationsP1/avgDegree.svg","components/posts/equationsP1/algConnect.svg","components/posts/equationsP1/ineq.svg","components/posts/equationsP1/natConnect1.svg","components/posts/equationsP1/natConnect2.svg","components/posts/equationsP1/e.svg","components/posts/equationsP1/avgHopCount.svg","components/posts/equationsP1/assortivity.svg","components/posts/equationsP1/INDEX.svg","components/home.js","components/posts/0.js","components/posts/1.js","components/main.js","components/about.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","App","TopBar","BlogTitle","Author","Note","React","Component","Fade","keyframes","styled","div","p","h1","Post","EntryTitle","Image","src","require","Caption","Subtitle","MainText","SmallImg","Eq","img","Date","entries","key","StyledDivider","Main","Stopper","hr","Holder","Title","About","props","handleResize","setState","w","window","innerWidth","h","innerHeight","state","bind","addEventListener","this","removeEventListener","Container","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c5dcedd7.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/subway_map.6716dc71.jpeg\";","module.exports = __webpack_public_path__ + \"static/media/graph_visual.b8b59136.png\";","module.exports = __webpack_public_path__ + \"static/media/inefficiency_fitness_eq.43a3468e.svg\";","module.exports = __webpack_public_path__ + \"static/media/eigen1.4b8799a9.svg\";","module.exports = __webpack_public_path__ + \"static/media/eigen2.f9351b80.svg\";","module.exports = __webpack_public_path__ + \"static/media/eigen3.1933b9ce.svg\";","module.exports = __webpack_public_path__ + \"static/media/Robustness.332fef72.svg\";","module.exports = __webpack_public_path__ + \"static/media/avgDegree.aff38a84.svg\";","module.exports = __webpack_public_path__ + \"static/media/algConnect.6e24af71.svg\";","module.exports = __webpack_public_path__ + \"static/media/ineq.f225688e.svg\";","module.exports = __webpack_public_path__ + \"static/media/natConnect1.96063010.svg\";","module.exports = __webpack_public_path__ + \"static/media/natConnect2.75e2a4ba.svg\";","module.exports = __webpack_public_path__ + \"static/media/e.d4f6f958.svg\";","module.exports = __webpack_public_path__ + \"static/media/avgHopCount.11a5a64c.svg\";","module.exports = __webpack_public_path__ + \"static/media/assortivity.cc5800e0.svg\";","module.exports = __webpack_public_path__ + \"static/media/INDEX.a7e8a164.svg\";","import React from 'react';\nimport styled, { keyframes } from 'styled-components';\n\nclass App extends React.Component {\n  render() {\n    return (\n      <TopBar>\n        <BlogTitle>\n          Moment's Notice\n        </BlogTitle>\n        <Author>\n          By Francis Park and Sean Rhee\n        </Author>\n        <Note>\n          Home ={'>'} Blog ={'>'} About\n        </Note>\n        <Note>\n          (scroll right)\n        </Note>\n      </TopBar>\n    );\n  }\n}\n\nexport default App;\n\nconst Fade = keyframes`\n  0% { color: #f2f2f200; }\n  40% { color: #f2f2f200; }\n  100% { color: #f2f2f255; }\n`;\n\nconst TopBar = styled.div`\n  display: flex;\n  height: 100%;\n  min-width: 100%;\n  background: linear-gradient(114deg, rgba(39,39,181,1) 0%, rgba(64,34,103,1) 39%, rgba(135,55,149,1) 74%, rgba(52,102,156,1) 100%);\n  color: #f2f2f2;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  scroll-snap-align: start;\n  scroll-snap-stop: always;\n`;\n\nconst Note = styled.p`\n  font-size: 12px;\n  color: #f2f2f255;\n  animation: ${Fade} 2s linear 1;\n  margin-top: -10px;\n`;\n\nconst BlogTitle = styled.h1`\n  color: #f2f2f2;\n  font-size: 34px;\n  font-weight: 300;\n  letter-spacing: 4px;\n`;\n\nconst Author = styled.h1`\n  margin-top: -14px;\n  color: #f2f2f2aa;\n  font-size: 14px;\n  font-weight: 200;\n  margin-bottom: 26px;\n`;\n\n/*\nconst Menu = styled.div`\n  width: 100vw;\n  height: 40px;\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: center;\n`;\n\nconst NavItem = styled.a`\n  padding-top: 9px;\n  flex: 1;\n  color: black;\n  font-size: 16px;\n  font-weight: 500;\n  text-align: center;\n  vertical-align: center;\n  text-decoration: none;\n`;\n\nconst Filler = styled.div`\n  flex: 4;\n`;\n\nconst Everything = styled.div`\n  width: 80vw;\n  padding-left: 10%;\n`;\n*/\n","import React from 'react';\nimport styled from 'styled-components';\n\nclass App extends React.Component {\n  render() {\n    return (\n      <Post>\n        <EntryTitle>\n          Improving Subway Efficiency — Part One \n        </EntryTitle>\n        <Date>\n          Written By Sean Rhee || Published Jan. 2020\n        </Date>\n        <Image src={require('./subway_map.jpeg')} />\n        <Caption>\n          Photo: Seoul Metropolitan Subway Map (Credit: Seoul Metro)\n        </Caption>\n        <Subtitle>\n          Introduction\n        </Subtitle>\n        <MainText>\n          The Seoul metro is considered one of the best in the world. Despite this, it still has various inefficiencies. For me, this is best seen in the fact that I can jog home from school faster than if I took subway. Maybe I'm just unlucky, but as great as Seoul's metro is, I feel like it can definitely be improved.\n        </MainText>\n        <MainText>\n          So that's essentially the background of this series. The goal is simple: make a better subway layout. Both Francis (co-contributor to Moment's Notice) and I will be trying to tackle this issue (each from a different angle). Personally, I hope to utilize machine learning to generate new maps (whereas Francis will be using a more purely mathematical approach). In this installment, I hope to outline the general methodology through which I will be approaching the problem. And with that, I'd now like to answer the fundamental question of how exactly someone could go about improving the Seoul metro's efficiency (although, as will become clear, this can be applied to all subways more generally).\n        </MainText>\n        <Subtitle>\n          \"Efficiency\"\n        </Subtitle>\n        <MainText>\n          First and foremost, I think it has to be made clear that there is no concrete definition of what makes a system like a subway necessarily efficient. For example, if we represent our subway graphically by assigning a vertex to each station, both a complete graph and minimum spanning tree could be argued to be an optimally efficient layout. This is because there are various aspects of a transport network that can determine efficiency with some of these factors being at odds with one another. With that in mind, let's look at efficiency a bit more closely.\n        </MainText>\n        <MainText>\n          As far as I'm concerned, there are three primary factors of importance when it comes to efficiency for our subway network: distance, commuter time, and service potential (which I'll explain).\n        </MainText>\n        <MainText>\n          Distance is obviously important because it wouldn't be feasible to build and maintain lines to and from every station in a system (unless there are like, four stations in total). Thinking back, a distance-optimized topology would resemble a minimum spanning tree.\n        </MainText>\n        <MainText>\n          Commuter time is also obviously important since the reason anyone uses transport in the first place is to get to and from places quickly. Again, thinking back, a commuter time–optimized topology would resemble a complete graph.\n        </MainText>\n        <MainText>\n          Unfortunately, as alluded to earlier, the two metrics of distance and commuter time are essentially in opposition: one can only be improved at the expense of the other. So how can these be balanced? Our answer comes in the form of service potential (as subjectively defined by the user/designer).\n        </MainText>\n        <MainText>\n          Service potential is, in essence, the \"importance\" of a station. Although this can be determined many ways, the way that I've decided to define this is through the creation of a list of the average traffic values of every station and normalizing them across some (arbitrary) range. The higher the service potential, the more time-optimized that station will be. The lower the service potential, the more distance-optimized that station will be.\n        </MainText>\n        <MainText>\n          Assigning a metro system an efficiency ultimately comes down to relating these three values (distance, commuter time, and service potential) in a reasonable, quantifiable, consistent, and repeatable way. We can then train a machine learning algorithm to output metro layouts and grade their fitness by using this newly derived efficiency value. Ultimately, this should result in us receiving a theoretically better map for the Seoul metro.\n        </MainText>\n        <Subtitle>\n          Method and Reasoning\n        </Subtitle>\n        <MainText>\n          Since a neural network will be the one generating our subway maps, it doesn't matter if we use efficiency or inefficiency when defining fitness for training (maximizing efficiency and minimizing inefficiency should be effectively identical). Because of this, an inefficiency metric will be used for the fitness function (since it's more intuitive to implement) with the goal being to minimize this function.\n        </MainText>\n        <MainText>\n          To abstractly represent our subway systems, we will be using weighted undirected graphs, but each graph won't be a direct analogue to the \"real-life\" layout. Essentially, each graph will be composed of multiple \"chains,\" so to speak. Each chain will represent an individual subway line with each vertex in each chain representing a certain station. The edge connecting any two vertices in a chain will be weighted according to the real-life euclidean distance between the two stations represented by those vertices plus some intermediate node penalty (INP). If the same station is in two or more chains, those chains will be connected at the shared station via a transfer edge. These transfer edges will be weighted according to some necessary transfer penalty (NTP). INPs and NTPs are assigned in order to incentivize the use of shorter or more time-optimized routes that avoid unnecessary stops and transfers.\n        </MainText>\n        <SmallImg src={require('./graph_visual.png')} />\n        <Caption>\n          A Basic Visualization of How this Graphical Representation Works\n        </Caption>\n        <MainText>\n          Using this graphical representation of any given subway system, we can finally obtain an inefficiency metric by iterating through each vertex, weighting the INP and NTP by our vertex's service potential (which, yes, means that the graph's edge weights will change as we iterate through stations), summing the minimum distances (found with a shortest path first, or SPF, algorithm such as Dijkstra's algorithm) from the current node to every other node, re-weighting each sum based on the start node's service potential, and averaging these weighted sums.\n        </MainText>\n        <MainText>\n          In English, this is all a bit hard to follow, so to imagine this mathematically, assuming you have <i>s</i> amount of stations with <i>V<sub>i</sub></i> and <i>V<sub>j</sub></i> representing the vertices (or stations) <i>i</i> and <i>j</i> respectively, by using <i>λ<sub>i</sub></i> for the service potential of <i>V<sub>i</sub></i> and some SPF algorithm <i>d(x, y)</i> to find the shortest path between x and y, this formula relates the information from the preceding paragraph:\n        </MainText>\n        <Eq src={require('./inefficiency_fitness_eq.svg')} />\n        <MainText>\n          Initially, this entire methodology may seem somewhat contrived, but with some thought, it should actually make a lot of intuitive sense. First, by using a station's traffic as its service potential, we can ensure that \"more important\" stations are more commuter time–optimized and are more prioritized while the \"less important\" stations are more distance-optimized and are less prioritized. This is because by weighting INPs and NTPs by service potential, a high service potential would result in the incentivization of visiting fewer stops and making fewer transfers. Additionally, by weighting our sum by service potential, minimizing our weighted sum for \"more important\" stations will matter more (which makes sense). The opposite applies for stations with low service potential. Also, the reason our abstracted chain representation even works to begin with is because a) if you imagine that our INPs and NTPs in the figure above (which visualizes our graphical representation) were of length 0, our chain model would resemble its real-life counterpart and b) if you think about it, the reason it's annoying to have lots of stops or transfers is because in that time, you could otherwise be travelling toward your destination meaning that having a stop or transfer is like having to travel extra distance which is why it makes sense to utilize INPs and NTPs at all. Finally, the reason we average our weighted sum at the end instead of something analogous such as summing our sums is because even though this would/should have a virtually identical effect on our machine learning algorithm, by averaging our sums, I'd assume that we'd have more normalized (and therefore comparable) values across multiple different subway systems.\n        </MainText>\n        <MainText>\n          One major problem is it's difficult to analyze the actual importance of certain routes. For example, even though some station, A, and another station, B, might both draw heavy traffic, this doesn't necessitate heavy traffic between A and B. A and B could be two hubs, so to speak, each with their own relatively contained subsystems. Unfortunately, since it's difficult to find data about the importance of actual routes themselves (unless we were to track people individually as they move around in a subway), the next best thing, if you ask me, is to just use station importance based on general traffic.\n        </MainText>\n        <MainText>\n          To summarize, the metric we're using is far from perfect, but its hard to make a perfect metric (and get data required for a perfect metric). Regardless, the method that has been devised to evaluate inefficiency should still be relatively effective as it can account for both distance and commuter time while providing a reasonable way to determine which to give more importance to.\n        </MainText>\n        <Subtitle>\n          Summary\n        </Subtitle>\n        <MainText>\n          From what I can tell, Seoul's metro topology isn't fully optimized. With Seoul having one of the best metro systems in the world, I'd assume that a similar statement could be said about almost every other metro system in the world. Because of this, I think it would make sense to devise a way to improve metro topology in general. To do this, I hope to train a machine learning algorithm to minimize an inefficiency metric that accounts for distance, commuter time, and service potential. Although there are certain drawbacks to the method proposed, it should still work relatively well (admittedly, this statement is backed by intuition rather than data). In future installments of this series, I hope to a) test our inefficiency metric on small, randomly generated \"subway maps\" b) scale this implementation for the actual Seoul Metro c) perhaps input data for other famous metro systems and compare generated maps and (in)efficiencies.\n        </MainText>\n      </Post>\n    );\n  }\n}\n\nexport default App;\n\nconst Post = styled.div`\n  width: 100%;\n  display: inline-block;\n`;\n\nconst Image = styled.img`\n  width: 100%;\n  display: block;\n  margin-left: auto;\n  margin-right: auto;\n`;\n\nconst SmallImg = styled.img`\n  width: 80%;\n  display: block;\n  margin-left: auto;\n  margin-right: auto;\n`;\n\nconst Eq = styled.img`\n  height: 90px;\n  display: block;\n  margin-left: auto;\n  margin-right: auto;\n  margin-top: 12px;\n  margin-bottom: 8px;\n`;\n\nconst Date = styled.h1`\n  color: #00000088;\n  font-size: 12px;\n  font-weight: 300;\n  margin-top: -12px;\n  margin-bottom: 26px;\n`;\n\nconst EntryTitle = styled.h1`\n  color: black;\n  font-size: 38px;\n  font-weight: 400;\n`;\n\nconst Subtitle = styled.h1`\n  color: black;\n  font-size: 30px;\n  font-weight: 500;\n  margin-left: 10%;\n  margin-right: 10%;\n  margin-top: 30px;\n`;\n\nconst MiniTitle = styled.h1`\n  color: black;\n  font-size: 26px;\n  font-weight: 500;\n  margin-left: 12%;\n  margin-right: 12%;\n  margin-top: 30px;\n`;\n\nconst SuppText = styled.h1`\n  color: #000000b5;\n  font-size: 20px;\n  font-weight: 400;\n  line-height: 26px;\n  margin-left: 12%;\n  margin-right: 13%;\n`;\n\nconst Caption = styled.p`\n  color: #000000b5;\n  font-size: 12px;\n  font-weight: 200;\n  margin-top: 5px;\n  text-align: center;\n`;\n\nconst MainText = styled.h1`\n  color: #000000b5;\n  font-size: 20px;\n  font-weight: 400;\n  line-height: 26px;\n  margin-left: 10%;\n  margin-right: 10%;\n`;\n","import React from 'react';\nimport styled from 'styled-components';\n\nclass App extends React.Component {\n  render() {\n    return (\n      <Post>\n        <EntryTitle>\n\t\t       Subway Enhancement Network Analysis – Part one\n        </EntryTitle>\n        <Date>\n\t\t      Written By Francis Park || Published Feb. 2020\n        </Date>\n      \t<Subtitle>\n      \t\tIntroduction\n      \t</Subtitle>\n        <MainText>\n      \t\tSeoul’s Metro system is often praised for its level of convenience, but, as Sean said before, it does not mean that it is perfect by all means. I’ll be taking a different approach from Sean; instead of making efforts to directly produce a network that is improved, I made efforts to create an index that could encapsulate both robustness and efficiency of a metro-network. I titled the cumulative index the <i>Park-Rhee Power Rating</i>, where “power” is a function of <i>robustness</i> and <i>efficiency</i> — more precisely the scaled, gradient sum. This way the index may guide future topological efforts. The intrinsic value in this is that it seeks to reconcile the often inverse relation between the latter two quantities — as presented in many forms of literature (i.e Peng et al. 2016). \n        </MainText>\n      \t<MainText>\n      \tAlso, it is important for me to address the fact that I wish to introduce a methodology where one can construct his/her indices for robustness and efficiency after metrics introduced in the standard literature and use it for analysis. Nothing I introduce here is an “answer” to anything, at least not yet, but rather a novel approach. \n      \t</MainText>\n      \t<Subtitle>\n      \t\tTerminology\n      \t</Subtitle>\n      \t<MainText>\n      \t\tI guess, for clarification, I’ll lay out some terminology. \n      \t</MainText>\n      \t<MainText>\n      \t\tWe denote an arbitrary graph <i>G</i> that consists of <i>N</i> nodes and <i>L</i>  links. In other words, we can conceptualize <i>N</i> as the set of stations (in the Seoul Metro network) and <i>L</i> as the total number of paths or routes.  \n      \t</MainText>\n      \t<MainText>\n      \t\tIt is also important to note we will be dealing with a graph that is undirected and unweighted for the time being.  \n      \t</MainText>\n      \t<MainText>\n      \t\tWe define the <i>Adjacency Matrix</i> as the square n by n matrix (with node set <i>V(G)</i> = {\"{\"}1,.......n{\"}\"}) where A<i><sub>ij</sub></i>  = A<i><sub>ij</sub></i>  — indices are “1” when there exists a link between arbitrary nodes i and j and indices are “0” otherwise.\n      \t</MainText>\n      \t<MainText>\n      \t\tThe <i>Eigenvector</i> of matrix A is the vector that remains parallel amidst a span. Mathematically, \n      \t</MainText>\n          <Eq src={require('./equationsP1/eigen1.svg')} />\n      \t<MainText>\n      \t\t,where lambda is the associated <i>Eigenvalue</i>. After factoring and tracing, the statement below follows\n      \t</MainText>\n      \t\t<Eq src={require('./equationsP1/eigen2.svg')} />\n      \t<MainText>\n      In this document (and others in relation to this post), we will refer to the tracing <i>(tr)</i> as <i>diagonalization</i>. Mathematically,\n      \t</MainText>\n\t\t<Eq src={require('./equationsP1/eigen3.svg')} />\n\t<MainText>\n\t\t<i>tr(A)</i> computes the sum of the eigenvalues of <i>A</i>, each taking multiplicity (divisible power) from roots of <i>det(A - Iv)</i> = 0. \n\t</MainText>\n\t<MainText>\n\tLastly, the <i>Laplacian Matrix</i>. But since Laplacian involves the degree matrix, we will first define “degree”. A <i>degree</i> of a node <i>i</i> simply refers to the number of edges incident to that node (number of connections).\n\t</MainText>\n\t<MainText>\n\tPut simply, the Laplacian Matrix <i>L(G) = D(G) - A(G)</i>, where <i>D(G)</i> refers to the degree matrix and <i>A(G)</i> refers to the adjacency matrix of network <i>G</i>.\n          </MainText>\n          <MainText>\n\tAnother important graphical metric I want to introduce is hop count. In this document, we will refer to the hop count as the minimum value within the set that contains all possible link paths that connect two stations (nodes). \n\t</MainText>\n          <MainText>\n\tAll denotations of <i>N</i> refer to a metro system’s total number of stations. We make this mention now as it is often involved (in the denominator) for the normalization of our chosen metrics. Also, all denotations of <i>L</i> refer to a metro system’s total pathways (links).\n\t</MainText>\n\t<Subtitle>\n\t\tRobustness\n\t</Subtitle>\n\t<MainText>\n\tWhat exactly is robustness? To deem something “robust” is often hard to define axiomatically (especially in academia); let alone grasp it. Yet, I believe, in context, it is rather intuitive.\n\t</MainText>\n\t<MainText>\n\tIn a metro-transport network, we can equate robustness to resilience - we wish to assess a topology’s ability to cope with worms, service faults, and other challenges. \n\t</MainText>\n\t<MainText>\n\tTo wit, we want to capture how well a graph can cope when routes (links) or stations (nodes) fail. For example, when one link fails, a graph is deemed more robust according to the number of alternative routes it has to the given node. \n\t</MainText>\n\t<MainText>\n\tIt is also important to note that this is a custom construction. Say, for example, we wished to assess the robustness of an epidemiological network (something I probably will post later). The metrics involved within its cumulative robustness, I presume, will differ slightly, maybe even completely, from the one below. \n\t</MainText>\n\t\t<Eq src={require('./equationsP1/Robustness.svg')} />\n\t<MainText>\n\tThat being said, our cumulative measure of Robustness, as displayed above, is the sum of three components. We wanted to make sure that our index could capture the proper tolerance of any metro-network, which should assess the “survivability” and the disruption tolerance of the topology itself. \n\t</MainText>\n\t\t<Eq src={require('./equationsP1/avgDegree.svg')} />\n\t<MainText>\n\tE*[D] denotes the average (normalized) degree of node (in this case station) <i>s<sub>i</sub></i>. A higher average degree implies more connections — implying a network that is more robust. Another alternative degree related examination involves degree distribution analysis. For example, if a network’s degree distribution resembles that of the power law it shows great resilience against random node failures (Cohen et. al 2001). Likewise, networks with many “influencers” (nodes with high rich club coefficient values) are extremely vulnerable to targeted attacks. A user of this methodology should take this into account upon personal construction.\n\t</MainText>\n\t\t<Eq src={require('./equationsP1/algConnect.svg')} />\n\t<MainText>\n\tThe next metric is <i>Algebraic Connectivity</i>. Given that <i>μ<sub>i</sub></i>…..<i>μ<sub>N</sub></i> is the list of ordered eigenvalues of an arbitrary network, algebraic connectivity is the second smallest of those values — denoted by <i>μ<sub>N-1</sub></i> above. We used connectivity as a means of grasping the disruption tolerance of the network. Connectivity usually involves constraints involving node or link removal and is currently established as a reliable, orthodox form of network resilience. Algebraic connectivity is 0 for disconnected graphs and > 0 when mildly or fully connected. Consider <i>K<sub>N</sub>(G)</i> and <i>K<sub>L</sub>(G)</i>, where they denote the minimum number of nodes and links respectively that lead to network disconnection (Meigham et. al 2011).\n\t</MainText>\n\t\t<Eq src={require('./equationsP1/ineq.svg')} />\n\t<MainText>\n\t\tHence, higher the algebraic connectivity, higher the level of disruption tolerance for the network. In other words, the higher the algebraic connectivity, the harder it is for break or cut the network into discrete pieces. Yet, this value is not very sensitive when applied to complex networks. Though extremely useful, some studies have referred to it as rather “coarse” and “binary” when analyzing complex networks (Jun et al. 2010). We seek to complement this value with <i>Natural Connectivity</i> . \n\t</MainText>\n\t\t<Eq src={require('./equationsP1/natConnect1.svg')} />\n\t\t<Eq src={require('./equationsP1/natConnect2.svg')} />\n\t<MainText>\n\t\twhere <i>λ<sub>i</sub></i> denotes eigenvalues of the adjacency matrix. The last metric is <i>Natural Connectivity</i>. It is much more sensitive to singular node attacks and is useful for expressing robustness in terms of alternate routings and pathways. Furthermore, it is a function of monotonic nature (Wang et al. 2016); the value shifts with the (singular) removal or addition of links. \n\t</MainText>\n\t<Subtitle>\n\t\tEfficiency\n\t</Subtitle>\n\t<MainText>\n\t\tEfficiency, like our previous metric, is not completely objective.\n\t</MainText>\n\t<MainText>\n\t\tFor a complex (metro) network, we deem a network efficient when it diffuses information quickly, has minimal hop count, and minimal information delay. The latter component, however, is impossible to implement logistically as it is too computational expensive and impractical. I do not believe Seoul Metropolitan collects data on how long passengers must wait (metro delay time). \n\t</MainText>\n\t<MainText>\n\t\tLiterature in China (Leng et. al 2016) reveals distinctions between passengers that care about sheer hop-count and euclidean distance when choosing their respective forms of transport or routing methods. We took that account when constructing the index. \n\t</MainText>\n\t\t<Eq src={require('./equationsP1/e.svg')} />\n\t<MainText>\n\t\tEfficiency, like our previous metric, is not completely objective.\n\t</MainText>\n\t\t<Eq src={require('./equationsP1/avgHopCount.svg')} />\n\t<MainText>\n\t\twhere <i>H<sub>ij</sub></i> denotes the hop count between stations <i>i</i> and <i>j</i>. E*[1/H] is the normalized reciprocal average hop count. The reciprocal was taken because it expands the criterion to one of global scale (Wang et. al 2016). \n\t</MainText>\n\t<MainText>\n\t\tE*[1/M] is the normalized reciprocal euclidean distance count. This is formalized exactly the same way average hop count besides replacing hop count with the sheer euclidean distance between the arbitrary stations and by adjusting the normalization process (denominated against largest service distance a pair of stations <i>i</i> and <i>j</i>). \n\t</MainText>\n\t\t<Eq src={require('./equationsP1/assortivity.svg')} />\n\t<MainText>\n\t where <i>s<sub>i</sub></i> and <i>s<sub>j</sub></i> denote the degrees of arbitrary stations. The last metric I want to introduce is assortativity. Though largely contrived and determined, experimentation (Ishikura et. al 2016) showed that assortativity values ranging from [-0.67, 0.58] lowered hop count and provided further “efficiency” enhancing benefits to a single network (I’ll for sure have to generate metro networks and analytically determine the associativity bounds myself later). To allow for some standardization, I had to choose whether our metric with reward assortativity, or its contrapositive, dissassortivity. It turns out that dissassortivity generally increases robustness and leads to poor network efficiency. So, for the integrity of our metric, I took absolute value into account and subtracted 0.5 (instead of 0.6 or 0.7 because that would then favor the lower bound) afterwards to appeal to the positive bound. \n\t</MainText>\n\t<MainText>\n\t\tAlso, the subtraction (from 3) involved was to account for the fact that the metrics were dealing with a level of inefficiency. In other words, if something is not inefficient what so ever, it is optimally efficient. \n\t</MainText>\n\t<Subtitle>\n\t\tPower?\n\t</Subtitle>\n\t<MainText>\n\t\tNow that we have finished going over our robustness and efficiency metrics, we will now look into power. Note that I added the question mark because I am not sure what to call this yet. \n\t</MainText>\n\t<MainText>\n\t\tThe power is the sum of robustness and efficiency. It is bounded between [0, 6]. \n\t</MainText>\n\t<MainText>\n\t\tThe index, which is to be described in the next section, rewards the maximum value and punishes the minimum value of power. A value of 3 is well received as it may imply perfection (or something near it) for one of power’s components. \n\t</MainText>\n\t<Subtitle>\n\t\tThe Index — Park-Rhee Power Rating\n\t</Subtitle>\n\t\t<Eq src={require('./equationsP1/INDEX.svg')} />\n\t<MainText>\n\t\twhere <i>p</i> denotes the value of the power rating, where <i>a</i>, <i>b</i>, <i>c</i>, <i>d</i>, <i>f</i>, <i>g</i>, denote 0.325, 6, 0.9, 1.3, 3, and 1 respectively. The index essentially is a function of power that scales the values from [0,1]. It is essentially a bijection. \n\t</MainText>\n\t<MainText>\n\t\tAs mentioned before, a value of 6 is rewarded with an index value of 1; a value of 3 is rewarded with a value of 0.5.  \n\t</MainText>\n\t<MainText>\n\t\tA higher value means the network is healthy. Likewise, a lower value means the network is in poor condition.\n\t</MainText>\n\t<MainText>\n\t\tOne may notice that the curvature resembles that of a normal curve. That is because its sensitivity rewards ideals and punishes mediocrity. However (as mentioned in the conclusion), this may seem too strict and may need adjusting as our system is currently still rather tertiary (only 3 layers). Also, our current model (gradient function) rewards robustness more than efficiency due to the function’s sheer nature.\n\t</MainText>\n\t<Subtitle>\n\t\tConclusion\n\t</Subtitle>\n\t<MainText>\n\t\tIn conclusion, I want to further this study by looking more into the individual metrics and then weighting them. With weighted coefficients, for example, one can weight the importance of say natural connectivity over that of algebraic connectivity. Of course, the prior conditionals are wholly subjective. To wit, if we create a weighted average system (similar in form to that of the “center of mass” formulation) for efficiency and robustness, we may receive more dynamic, modeled results. That would entail significant modifications to the index function, albeit modification is needed regardless due to its strained-sensitivity and mediocrity-punishing flaws. \n\t</MainText>\n\t<MainText>\n\t\tAfter this, I hope to reduce the previous indices into a data frame or equation that is inexpensive for Sean to use as a fitness function for breeding. Another application of this index can be to apply it and see for myself the values of the index for multiple other country metro-networks and give suggestions for improvement respectively. I think I'll compare the metros purely numerically as radial diagrams or geometrical formulations can't account for the goal differences between effiency and robustness. For the numerical analysis itself, I’ll conduct joint analysis using <i>Gephi</i>, <i>Rstudio</i> and perhaps <i>MatSim</i>.\n\t</MainText>\n\t<MainText>\n\t\tI’ll be taking a break from the mentioned steps and start looking into epidemiological modeling or the N-Body problem for the next post. Feedback and critique are much appreciated.\n\t</MainText>\n      </Post>\n    );\n  }\n}\n\nexport default App;\n\nconst Post = styled.div`\n  width: 100%;\n  display: inline-block;\n`;\n\nconst Image = styled.img`\n  width: 100%;\n  display: block;\n  margin-left: auto;\n  margin-right: auto;\n`;\n\nconst SmallImg = styled.img`\n  width: 80%;\n  display: block;\n  margin-left: auto;\n  margin-right: auto;\n`;\n\nconst Date = styled.h1`\n  color: #00000088;\n  font-size: 12px;\n  font-weight: 300;\n  margin-top: -12px;\n  margin-bottom: 26px;\n`;\n\nconst EntryTitle = styled.h1`\n  color: black;\n  font-size: 38px;\n  font-weight: 400;\n`;\n\nconst Subtitle = styled.h1`\n  color: black;\n  font-size: 26px;\n  font-weight: 500;\n  margin-left: 10%;\n  margin-right: 10%;\n  margin-top: 30px;\n`;\n\nconst Caption = styled.p`\n  color: #000000b5;\n  font-size: 12px;\n  font-weight: 200;\n  margin-top: 0px;\n  text-align: center;\n`;\n\nconst MainText = styled.h1`\n  color: #000000b5;\n  font-size: 18px;\n  font-weight: 400;\n  line-height: 26px;\n  margin-left: 10%;\n  margin-right: 10%;\n`;\n\nconst Eq = styled.img`\n  display: block;\n  margin-left: auto;\n  margin-right: auto;\n  margin-top: 14px;\n  margin-bottom: 14px;\n`;\n","import React from 'react';\nimport styled from 'styled-components';\nimport Post0 from './posts/0';\nimport Post1 from './posts/1';\n\nclass App extends React.Component {\n  render() {\n    var entries = [\n      <Post1 key={1} />,\n      <StyledDivider />,\n      <Post0 key={0}/>,\n      <StyledDivider />\n    ]\n\n    return (\n      <Main>\n        <Stopper />\n        {entries}\n        <Stopper />\n      </Main>\n    );\n  }\n}\n\nexport default App;\n\nconst Main = styled.div`\n  min-width: 80%;\n  padding-left: 10%;\n  padding-right: 10%;\n  overflow-y: scroll;\n  scroll-snap-align: start;\n  scroll-snap-stop: always;\n  scrollbar-width: none;\n  background-color: #fafafa;\n`;\n\nconst Stopper = styled.div`\n  height: 30px;\n`;\n\nconst StyledDivider = styled.hr`\n  border-top: 1px dashed #a5a7b0;\n  border-bottom: 0px\n  margin-top: 32px;\n`;\n","import React from 'react';\nimport styled from 'styled-components';\n\nclass App extends React.Component {\n  render() {\n    return (\n      <Holder>\n        <Stopper />\n        <Title>\n          About This Blog\n        </Title>\n        <Subtitle>\n          Authors\n        </Subtitle>\n        <About>\n          Moment's Notice has two authors: Sean Rhee and Francis Park.\n          <br /><br />\n          Sean is a senior at the Yongsan International School of Seoul (YISS). He has an interest in a wide range of subjects from computer science, to physics, to international relations, to engineering, to music theory/composition. He likes running and is on both the cross country team and track and field team at YISS.\n          <br /><br />\n          Francis is also a senior at YISS. He is an avid Jazz & Hip-Hop listener. He enjoys playing (right-bench or the occasional start) for his school's varsity boys soccer team. Francis' interests include mathematics (number theory, discrete mathematics, time series), atmospheric sciences, unsupervised learning, and writing short stories. His friends refer to him as 'chunky'.\n        </About>\n        <br />\n        <Subtitle>\n          \"Moment's Notice\"\n        </Subtitle>\n        <About>\n          Created on January 14, 2020, this blog's title was inspired by John Coltrane's <i>Moment's Notice</i>. As the name suggests, the title of this blog was chosen on a moment's notice. Similarly, we plan on posting whenever we feel is suitable on topics that capture our curiosity. This is a relatively STEM-oriented blog, but its contents won't necessarily be limited to STEM.\n        </About>\n        <br />\n        <Subtitle>\n          Purpose\n        </Subtitle>\n        <About>\n          While the purpose of this blog is to act as a forum for sharing ideas (and getting feedback regarding these ideas), it's also just for fun. We hope other people find the concepts and areas we explore to be interesting and worth delving further into.\n        </About>\n        <br />\n        <Subtitle>\n          Contact\n        </Subtitle>\n        <About>\n          email: momentsnoticecontact@gmail.com\n          <br /><br />\n          **We'll try to respond to everything, but unless this blog by some miracle takes off, chances are we won't be checking this inbox super often.\n        </About>\n        <Stopper />\n      </Holder>\n    );\n  }\n}\n\nexport default App;\n\nconst Holder = styled.div`\n  min-width: 80%;\n  padding-left: 10%;\n  padding-right: 10%;\n  overflow-y: scroll;\n  scroll-snap-align: start;\n  scroll-snap-stop: always;\n  scrollbar-width: none;\n  background: linear-gradient(90deg, #a5a7b0 0%, #fafafa 0.1%, #fafafa 100%);;\n`;\n\nconst Stopper = styled.div`\n  height: 30px;\n`;\n\nconst Title = styled.h1`\n  color: black;\n  font-size: 38px;\n  font-weight: 400;\n`;\n\nconst Subtitle = styled.h1`\n  color: black;\n  font-size: 26px;\n  font-weight: 500;\n`;\n\nconst About = styled.h1`\n  color: #000000b5;\n  font-size: 18px;\n  font-weight: 400;\n  line-height: 26px;\n`;\n","import React from 'react';\nimport styled from 'styled-components';\n\nimport Home from './components/home';\nimport Main from './components/main';\nimport About from './components/about';\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      w: window.innerWidth,\n      h: window.innerHeight,\n    }\n    this.handleResize = this.handleResize.bind(this);\n  }\n\n  componentDidMount() {\n    window.addEventListener('resize', this.handleResize);\n  }\n\n  componentWillUnmount() {\n    window.removeEventListener('resize', this.handleResize);\n  }\n\n  handleResize = () => {\n    this.setState({ w: window.innerWidth });\n    this.setState({ h: window.innerHeight });\n  }\n\n  render() {\n    return (\n      <Container w={this.state.w} h={this.state.h}>\n        <Home h={this.state.h}/>\n        <Main />\n        <About />\n      </Container>\n    );\n  }\n}\n\nexport default App;\n\nconst Container = styled.div`\n  display: flex;\n  flex-flow: row nowrap;\n  width: ${props => props.w};\n  height: ${props => props.h}px;\n  overflow-x: scroll;\n  overflow-y: auto;\n  scroll-snap-type: x mandatory;\n  scrollbar-width: none;\n  ::-webkit-scrollbar {\n    display: none!important;\n    height: 0;\n    width: 0;\n    background-color: transparent;\n   }\n`;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}